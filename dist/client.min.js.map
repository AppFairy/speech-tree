{"version":3,"sources":["webpack:///client.min.js","webpack:///webpack/bootstrap c1aa980cbc7b8549edf0","webpack:///./src/client/speech_emitter.js","webpack:///./src/settings.js","webpack:///./src/client/index.js","webpack:///./src/client/label_matcher.js","webpack:///./src/client/libs/speech_recognition.js","webpack:///./src/client/speech_listener.js","webpack:///./src/client/speech_node.js"],"names":["module","exports","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_toConsumableArray","arr","Array","isArray","arr2","length","from","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","descriptor","writable","key","protoProps","staticProps","SpeechEmitter","arguments","undefined","this","_events","Map","_handlers","test","handler","RegExp","handlers","set","_this","wrappedHandler","off","delete","sentence","_len","args","_key","forEach","result","concat","match","toLowerCase","then","catch","Promise","resolve","error","console","default","apiUrl","_interopRequireDefault","obj","_settings","_label_matcher","_speech_listener","_speech_node","createLabelMatcher","speechEmitter","labelEmitter","_speech_emitter2","fetchHandler","encodedSentence","encodeURIComponent","labelQueryUrl","_settings2","request","Request","fetch","response","json","_ref","label","emit","setTimeout","once","matchLabel","labelTest","actualLabel","on","dispose","_speech_emitter","SpeechRecognition","window","webkitSpeechRecognition","Error","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","constructor","setPrototypeOf","__proto__","_speech_recognition","_speech_recognition2","SpeechListener","_SpeechEmitter","options","getPrototypeOf","_listening","_speechRecognition","continuous","onresult","_handleSpeechResult","bind","start","stop","e","results","transcript","trim","_slicedToArray","sliceIterator","_arr","_n","_d","_e","_s","_i","Symbol","iterator","next","done","push","err","SpeechNode","parentNode","testsBatch","tests","_tests","getTestsRecursively","_ref2","speechNodeRequest","map","apply","parentTests"],"mappings":"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","file":"client.min.js","sourcesContent":["module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 7);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// This is a special event emitter which invokes a handler whenever there was a match\n// with the emitted sentence. The match can be done based on a string,\n// regular expression or a custom handler. The handler can return a promise as well,\n// making the matching process asynchronous and not necessarily synchronous\nvar SpeechEmitter = function () {\n  function SpeechEmitter() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, SpeechEmitter);\n\n    this._events = new Map();\n    this._handlers = new Map();\n  }\n\n  // Register a permanent event until being disposed manually\n\n\n  _createClass(SpeechEmitter, [{\n    key: 'on',\n    value: function on(test, handler) {\n      if (test == null) {\n        throw TypeError('test must be provided');\n      }\n\n      if (!(test instanceof RegExp) && typeof test != 'string' && typeof test != 'function') {\n        throw TypeError('test must be a regular expression, a string or a function');\n      }\n\n      if (handler == null) {\n        throw TypeError('handler must be provided');\n      }\n\n      if (typeof handler != 'function') {\n        throw TypeError('handler must be a function');\n      }\n\n      var handlers = this._events.get(test);\n\n      if (handlers == null) {\n        handlers = new Map();\n        this._events.set(test, handlers);\n      }\n\n      handlers.set(handler, handler);\n    }\n\n    // Register a one time event\n\n  }, {\n    key: 'once',\n    value: function once(test, handler) {\n      var _this = this;\n\n      if (test == null) {\n        throw TypeError('test must be provided');\n      }\n\n      if (!(test instanceof RegExp) && typeof test != 'string' && typeof test != 'function') {\n        throw TypeError('test must be a regular expression, a string or a function');\n      }\n\n      if (handler == null) {\n        throw TypeError('handler must be provided');\n      }\n\n      if (typeof handler != 'function') {\n        throw TypeError('handler must be a function');\n      }\n\n      var wrappedHandler = function wrappedHandler() {\n        _this.off(test, handler);\n        handler.apply(undefined, arguments);\n      };\n\n      var handlers = this._events.get(test);\n\n      if (handlers == null) {\n        handlers = new Map();\n        this._events.set(test, handlers);\n      }\n\n      handlers.set(handler, wrappedHandler);\n    }\n\n    // Dispose event\n\n  }, {\n    key: 'off',\n    value: function off(test, handler) {\n      // If non was provided, dispose all events\n      if (test == null && handler == null) {\n        this._events = new Map();\n        return;\n      }\n\n      // If handler wasn't provided, dispose all handlers matching the provided test\n      if (handler == null) {\n        this._events.delete(test);\n        return;\n      }\n\n      // Else, cancel the specifically provided handler\n      var handlers = this._events.get(test);\n\n      if (handlers != null) {\n        handlers.delete(handler);\n      }\n    }\n\n    // Emit an event. The rest of the arguments will be forwarded to the test handlers\n\n  }, {\n    key: 'emit',\n    value: function emit(sentence) {\n      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      if (sentence == null) {\n        throw TypeError('sentence must be provided');\n      }\n\n      if (typeof sentence != 'string') {\n        throw TypeError('sentence must be a string');\n      }\n\n      this._events.forEach(function (handlers, test) {\n        var result = void 0;\n\n        if (typeof test == 'function') {\n          result = test.apply(undefined, [sentence].concat(args));\n        } else if (test instanceof RegExp) {\n          result = sentence.match(new RegExp(test, 'i'));\n        } else if (test.toLowerCase() === sentence.toLowerCase()) {\n          result = sentence;\n        }\n\n        if (result == null) return;\n\n        if (typeof result.then != 'function' || typeof result.catch != 'function') {\n          result = Promise.resolve(result);\n        }\n\n        result.then(function (args) {\n          if (args == null) return;\n\n          args = [].concat(args);\n\n          handlers.forEach(function (handler) {\n            handler.apply(undefined, _toConsumableArray(args));\n          });\n        }).catch(function (error) {\n          console.error(error);\n        });\n      });\n    }\n  }]);\n\n  return SpeechEmitter;\n}();\n\nexports.default = SpeechEmitter;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = {\n  apiUrl: '/speech-tree'\n};\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _settings = __webpack_require__(1);\n\nObject.defineProperty(exports, 'settings', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_settings).default;\n  }\n});\n\nvar _label_matcher = __webpack_require__(3);\n\nObject.defineProperty(exports, 'createLabelMatcher', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_label_matcher).default;\n  }\n});\n\nvar _speech_listener = __webpack_require__(5);\n\nObject.defineProperty(exports, 'SpeechEmitter', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_speech_listener).default;\n  }\n});\nObject.defineProperty(exports, 'SpeechListener', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_speech_listener).default;\n  }\n});\n\nvar _speech_node = __webpack_require__(6);\n\nObject.defineProperty(exports, 'SpeechNode', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_speech_node).default;\n  }\n});\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _settings = __webpack_require__(1);\n\nvar _settings2 = _interopRequireDefault(_settings);\n\nvar _speech_emitter = __webpack_require__(0);\n\nvar _speech_emitter2 = _interopRequireDefault(_speech_emitter);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// This module can generate tester functions which will validate incoming sentences\n// against a label which can be fetched from the server using the provided plug-ins.\n// This is useful because it implements a complicated logic in an efficient way, and it\n// makes the classification process much easier to hook up with the client.\n//\n// Example:\n//\n//   const matchLabel = createLabelMatcher(listener);\n//\n//   speech.on(matchLabel('print')).invoke((sentence) => {\n//     console.log(sentence);\n//   });\n//\n\n// This will start listening for incoming sentences and will fetch labels from the server\n// each time a speech was recognized. It will return a factory function which will\n// generate an event handler for testing sentences against fetched labels\nfunction createLabelMatcher(speechEmitter) {\n  if (speechEmitter == null) {\n    throw TypeError('speech emitter must be provided');\n  }\n\n  if (!(speechEmitter instanceof _speech_emitter2.default)) {\n    throw TypeError('first argument must be a speech emitter');\n  }\n\n  // This will be used to register events for fetched labels\n  var labelEmitter = new _speech_emitter2.default();\n  var sentencePattern = /.*/;\n\n  // This will fetch labels and emit them whenever there is an incoming sentence\n  var fetchHandler = function fetchHandler(sentence) {\n    // e.g. ' ' (space) will be replaced with '%20'\n    var encodedSentence = encodeURIComponent(sentence);\n    var labelQueryUrl = _settings2.default.apiUrl + '/label?sentence=' + encodedSentence;\n    var request = new Request(labelQueryUrl);\n\n    fetch(request).then(function (response) {\n      return response.json();\n    }).then(function (_ref) {\n      var label = _ref.label;\n\n      labelEmitter.emit(label, sentence);\n\n      // Re-register event listener after it (could have been) zeroed by the speech node.\n      // Here we wait run the registration in the next event loop to ensure all promises\n      // have been resolved\n      setTimeout(function () {\n        speechEmitter.once(sentencePattern, fetchHandler);\n      });\n    }).catch(function (error) {\n      console.error(error);\n    });\n  };\n\n  // Here we use the once() method and not the on() method we re-register the event\n  // listener once a fetch has been done\n  speechEmitter.once(sentencePattern, fetchHandler);\n\n  // A factory function which will generate an event handler for matching sentences\n  // against fetched labels. Be sure to call the dispose() method once you don't need\n  // the labels logic anymore! Otherwise requests will keep being made to the server\n  // in the background\n  var matchLabel = function matchLabel(label) {\n    if (label == null) {\n      throw TypeError('label must be provided');\n    }\n\n    if (typeof label != 'string') {\n      throw TypeError('label must be a string');\n    }\n\n    // An async event handler which returns a promise\n    return function () {\n      return new Promise(function (resolve) {\n        // The promise will resolve itself whenever an emitted label matches the\n        // expected label\n        var labelTest = function labelTest(actualLabel, sentence) {\n          // This makes it a one-time test\n          labelEmitter.off(labelTest);\n\n          if (actualLabel == label) {\n            // These are the arguments with whom the event handler will be invoked with\n            return [sentence, label];\n          }\n        };\n\n        labelEmitter.on(labelTest, resolve);\n      });\n    };\n  };\n\n  // The disposal methods disposes all the registered label events and it stops the\n  // auto-fetching to the server whenever there is an incoming sentence\n  matchLabel.dispose = function () {\n    speechEmitter.off(sentencePattern, fetchHandler);\n    labelEmitter.off();\n  };\n\n  return matchLabel;\n}\n\nexports.default = createLabelMatcher;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n// A simple wrapped around the native speech recognition class which if our browser\n// runs webkit or not, and will give us the right class accordingly. If the current\n// version of the browser doesn't support speech recognition (natively), an error\n// will be thrown\nvar SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;\n\nif (!SpeechRecognition) {\n  throw Error(\"browser doesn't support web speech API\");\n}\n\nexports.default = SpeechRecognition;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _speech_recognition = __webpack_require__(4);\n\nvar _speech_recognition2 = _interopRequireDefault(_speech_recognition);\n\nvar _speech_emitter = __webpack_require__(0);\n\nvar _speech_emitter2 = _interopRequireDefault(_speech_emitter);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n// SpeechListener wraps the native speech recognition web API and will emit an event\n// whenever there is an incoming sentence\nvar SpeechListener = function (_SpeechEmitter) {\n  _inherits(SpeechListener, _SpeechEmitter);\n\n  _createClass(SpeechListener, [{\n    key: 'listening',\n    get: function get() {\n      return this._listening;\n    }\n  }]);\n\n  function SpeechListener() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, SpeechListener);\n\n    var _this = _possibleConstructorReturn(this, (SpeechListener.__proto__ || Object.getPrototypeOf(SpeechListener)).call(this));\n\n    _this._listening = false;\n    _this._speechRecognition = new _speech_recognition2.default();\n    _this._speechRecognition.continuous = options.continuous;\n    _this._speechRecognition.onresult = _this._handleSpeechResult.bind(_this);\n    return _this;\n  }\n\n  _createClass(SpeechListener, [{\n    key: 'start',\n    value: function start() {\n      this._speechRecognition.start();\n      this._listening = true;\n    }\n  }, {\n    key: 'stop',\n    value: function stop() {\n      this._speechRecognition.stop();\n      this._listening = false;\n    }\n  }, {\n    key: '_handleSpeechResult',\n    value: function _handleSpeechResult(e) {\n      var sentence = e.results[e.results.length - 1][0].transcript.trim();\n      this.emit(sentence);\n    }\n  }]);\n\n  return SpeechListener;\n}(_speech_emitter2.default);\n\nexports.default = SpeechListener;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _speech_emitter = __webpack_require__(0);\n\nvar _speech_emitter2 = _interopRequireDefault(_speech_emitter);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// An instance of the SpeechNode class represents a single node in an entire tree where\n// we can register events to voice commands in sequence.\n//\n// Example:\n//\n//   - \"Show me a list of all my expenses throughout the entire year\"\n//   - \"Please sort the list\"\n//\nvar SpeechNode = function () {\n  function SpeechNode(speechEmitter, parentNode) {\n    _classCallCheck(this, SpeechNode);\n\n    if (speechEmitter == null) {\n      throw TypeError('speech emitter must be provided');\n    }\n\n    if (!(speechEmitter instanceof _speech_emitter2.default)) {\n      throw TypeError('first argument must be a speech emitter');\n    }\n\n    if (parentNode && !(parentNode instanceof SpeechNode)) {\n      throw TypeError('second argument must be a speech node');\n    }\n\n    this.speechEmitter = speechEmitter;\n    this.parentNode = parentNode;\n    // We can register multiple tests for a single handler. This array is used to\n    // accumulate tests until their handler is being specified, in which case this array\n    // pipes itself to the global tests array\n    this.testsBatch = [];\n    // A test-handler pairs array which will be used to register itself after the speech\n    // commands map has been zeroed\n    this.tests = [];\n  }\n\n  _createClass(SpeechNode, [{\n    key: 'on',\n    value: function on(test) {\n      if (test == null) {\n        throw TypeError('test must be provided');\n      }\n\n      if (!(test instanceof RegExp) && typeof test != 'string' && typeof test != 'function') {\n        throw TypeError('test must be a regular expression, a string or a function');\n      }\n\n      // Accumulate test for the current session\n      this.testsBatch.push(test);\n\n      return this;\n    }\n  }, {\n    key: 'invoke',\n    value: function invoke(handler) {\n      var _this = this,\n          _tests;\n\n      if (handler == null) {\n        throw TypeError('test handler must be provided');\n      }\n\n      if (typeof handler != 'function') {\n        throw TypeError('test handler must be a function');\n      }\n\n      var wrappedHandler = function wrappedHandler() {\n        // Re-register all tests of the current node and above, discarding all events\n        // of child nodes\n        _this.speechEmitter.off();\n\n        _this.getTestsRecursively().forEach(function (_ref) {\n          var _ref2 = _slicedToArray(_ref, 2),\n              test = _ref2[0],\n              handler = _ref2[1];\n\n          _this.speechEmitter.on(test, handler);\n        });\n\n        // If the handler returns a function it means that the user would like to keep\n        // building the speech tree\n        var speechNodeRequest = handler.apply(undefined, arguments);\n\n        if (typeof speechNodeRequest != 'function') return;\n\n        speechNodeRequest(new SpeechNode(_this.speechEmitter, _this));\n      };\n\n      this.testsBatch.forEach(function (test) {\n        _this.speechEmitter.on(test, wrappedHandler);\n      });\n\n      // Compose test-handler pairs\n      var testsBatch = this.testsBatch.map(function (test) {\n        return [test, wrappedHandler];\n      });\n\n      // Pipe tests for current session\n      (_tests = this.tests).push.apply(_tests, _toConsumableArray(testsBatch));\n      this.testsBatch = [];\n\n      return this;\n    }\n\n    // Gets tests of the current node and all its parents\n\n  }, {\n    key: 'getTestsRecursively',\n    value: function getTestsRecursively() {\n      var parentTests = void 0;\n\n      if (this.parentNode) {\n        parentTests = this.parentNode.getTestsRecursively();\n      } else {\n        parentTests = [];\n      }\n\n      return this.tests.concat(parentTests);\n    }\n  }]);\n\n  return SpeechNode;\n}();\n\nexports.default = SpeechNode;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(2);\n\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// client.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 7);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap c1aa980cbc7b8549edf0","// This is a special event emitter which invokes a handler whenever there was a match\n// with the emitted sentence. The match can be done based on a string,\n// regular expression or a custom handler. The handler can return a promise as well,\n// making the matching process asynchronous and not necessarily synchronous\nclass SpeechEmitter {\n  constructor(options = {}) {\n    this._events = new Map();\n    this._handlers = new Map();\n  }\n\n  // Register a permanent event until being disposed manually\n  on(test, handler) {\n    if (test == null) {\n      throw TypeError('test must be provided');\n    }\n\n    if (!(test instanceof RegExp) &&\n        typeof test != 'string' &&\n        typeof test != 'function') {\n      throw TypeError('test must be a regular expression, a string or a function');\n    }\n\n    if (handler == null) {\n      throw TypeError('handler must be provided');\n    }\n\n    if (typeof handler != 'function') {\n      throw TypeError('handler must be a function');\n    }\n\n    let handlers = this._events.get(test);\n\n    if (handlers == null) {\n      handlers = new Map();\n      this._events.set(test, handlers);\n    }\n\n    handlers.set(handler, handler);\n  }\n\n  // Register a one time event\n  once(test, handler) {\n    if (test == null) {\n      throw TypeError('test must be provided');\n    }\n\n    if (!(test instanceof RegExp) &&\n        typeof test != 'string' &&\n        typeof test != 'function') {\n      throw TypeError('test must be a regular expression, a string or a function');\n    }\n\n    if (handler == null) {\n      throw TypeError('handler must be provided');\n    }\n\n    if (typeof handler != 'function') {\n      throw TypeError('handler must be a function');\n    }\n\n    const wrappedHandler = (...args) => {\n      this.off(test, handler);\n      handler(...args);\n    };\n\n    let handlers = this._events.get(test);\n\n    if (handlers == null) {\n      handlers = new Map();\n      this._events.set(test, handlers);\n    }\n\n    handlers.set(handler, wrappedHandler);\n  }\n\n  // Dispose event\n  off(test, handler) {\n    // If non was provided, dispose all events\n    if (test == null && handler == null) {\n      this._events = new Map();\n      return;\n    }\n\n    // If handler wasn't provided, dispose all handlers matching the provided test\n    if (handler == null) {\n      this._events.delete(test);\n      return;\n    }\n\n    // Else, cancel the specifically provided handler\n    const handlers = this._events.get(test);\n\n    if (handlers != null) {\n      handlers.delete(handler);\n    }\n  }\n\n  // Emit an event. The rest of the arguments will be forwarded to the test handlers\n  emit(sentence, ...args) {\n    if (sentence == null) {\n      throw TypeError('sentence must be provided');\n    }\n\n    if (typeof sentence != 'string') {\n      throw TypeError('sentence must be a string');\n    }\n\n    this._events.forEach((handlers, test) => {\n      let result;\n\n      if (typeof test == 'function') {\n        result = test(sentence, ...args);\n      }\n      else if (test instanceof RegExp) {\n        result = sentence.match(new RegExp(test, 'i'));\n      }\n      else if (test.toLowerCase() === sentence.toLowerCase()) {\n        result = sentence;\n      }\n\n      if (result == null) return;\n\n      if (typeof result.then != 'function' ||\n          typeof result.catch != 'function') {\n        result = Promise.resolve(result);\n      }\n\n      result.then((args) => {\n        if (args == null) return;\n\n        args = [].concat(args);\n\n        handlers.forEach((handler) => {\n          handler(...args);\n        });\n      })\n      .catch((error) => {\n        console.error(error);\n      });\n    });\n  }\n}\n\nexport default SpeechEmitter;\n\n\n\n// WEBPACK FOOTER //\n// ./src/client/speech_emitter.js","export default {\n  apiUrl: '/speech-tree'\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/settings.js","// Quick setup example:\n//\n//   const listener = new SpeechListener({ continuous: true });\n//   const speech = new SpeechNode(listener);\n//\n//   speech\n//     .on(/print (.+)/).invoke((sentence, message) => {\n//       console.log(message);\n//     })\n//     .on('stop listening').invoke(() => {\n//       listener.stop();\n//     });\n//\n//   listener.start();\n//\nexport { default as settings } from '../settings';\nexport { default as createLabelMatcher } from './label_matcher';\nexport { default as SpeechEmitter } from './speech_listener';\nexport { default as SpeechListener } from './speech_listener';\nexport { default as SpeechNode } from './speech_node';\n\n\n\n// WEBPACK FOOTER //\n// ./src/client/index.js","import settings from '../settings';\nimport SpeechEmitter from './speech_emitter';\n\n// This module can generate tester functions which will validate incoming sentences\n// against a label which can be fetched from the server using the provided plug-ins.\n// This is useful because it implements a complicated logic in an efficient way, and it\n// makes the classification process much easier to hook up with the client.\n//\n// Example:\n//\n//   const matchLabel = createLabelMatcher(listener);\n//\n//   speech.on(matchLabel('print')).invoke((sentence) => {\n//     console.log(sentence);\n//   });\n//\n\n// This will start listening for incoming sentences and will fetch labels from the server\n// each time a speech was recognized. It will return a factory function which will\n// generate an event handler for testing sentences against fetched labels\nfunction createLabelMatcher(speechEmitter) {\n  if (speechEmitter == null) {\n    throw TypeError('speech emitter must be provided');\n  }\n\n  if (!(speechEmitter instanceof SpeechEmitter)) {\n    throw TypeError('first argument must be a speech emitter');\n  }\n\n  // This will be used to register events for fetched labels\n  const labelEmitter = new SpeechEmitter();\n  const sentencePattern = /.*/;\n\n  // This will fetch labels and emit them whenever there is an incoming sentence\n  const fetchHandler = (sentence) => {\n    // e.g. ' ' (space) will be replaced with '%20'\n    const encodedSentence = encodeURIComponent(sentence);\n    const labelQueryUrl = `${settings.apiUrl}/label?sentence=${encodedSentence}`;\n    const request = new Request(labelQueryUrl);\n\n    fetch(request).then(response => response.json()).then(({ label }) => {\n      labelEmitter.emit(label, sentence);\n\n      // Re-register event listener after it (could have been) zeroed by the speech node.\n      // Here we wait run the registration in the next event loop to ensure all promises\n      // have been resolved\n      setTimeout(() => {\n        speechEmitter.once(sentencePattern, fetchHandler);\n      });\n    })\n    .catch((error) => {\n      console.error(error);\n    });\n  };\n\n  // Here we use the once() method and not the on() method we re-register the event\n  // listener once a fetch has been done\n  speechEmitter.once(sentencePattern, fetchHandler);\n\n  // A factory function which will generate an event handler for matching sentences\n  // against fetched labels. Be sure to call the dispose() method once you don't need\n  // the labels logic anymore! Otherwise requests will keep being made to the server\n  // in the background\n  const matchLabel = (label) => {\n    if (label == null) {\n      throw TypeError('label must be provided');\n    }\n\n    if (typeof label != 'string') {\n      throw TypeError('label must be a string');\n    }\n\n    // An async event handler which returns a promise\n    return () => new Promise((resolve) => {\n      // The promise will resolve itself whenever an emitted label matches the\n      // expected label\n      const labelTest = (actualLabel, sentence) => {\n        // This makes it a one-time test\n        labelEmitter.off(labelTest);\n\n        if (actualLabel == label) {\n          // These are the arguments with whom the event handler will be invoked with\n          return [sentence, label];\n        }\n      };\n\n      labelEmitter.on(labelTest, resolve);\n    });\n  };\n\n  // The disposal methods disposes all the registered label events and it stops the\n  // auto-fetching to the server whenever there is an incoming sentence\n  matchLabel.dispose = () => {\n    speechEmitter.off(sentencePattern, fetchHandler);\n    labelEmitter.off();\n  };\n\n  return matchLabel;\n}\n\nexport default createLabelMatcher;\n\n\n\n// WEBPACK FOOTER //\n// ./src/client/label_matcher.js","// A simple wrapped around the native speech recognition class which if our browser\n// runs webkit or not, and will give us the right class accordingly. If the current\n// version of the browser doesn't support speech recognition (natively), an error\n// will be thrown\nconst SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;\n\nif (!SpeechRecognition) {\n  throw Error(\"browser doesn't support web speech API\");\n}\n\nexport default SpeechRecognition;\n\n\n\n// WEBPACK FOOTER //\n// ./src/client/libs/speech_recognition.js","import SpeechRecognition from 'speech_recognition';\nimport SpeechEmitter from './speech_emitter';\n\n// SpeechListener wraps the native speech recognition web API and will emit an event\n// whenever there is an incoming sentence\nclass SpeechListener extends SpeechEmitter {\n  get listening() {\n    return this._listening;\n  }\n\n  constructor(options = {}) {\n    super();\n\n    this._listening = false;\n    this._speechRecognition = new SpeechRecognition();\n    this._speechRecognition.continuous = options.continuous;\n    this._speechRecognition.onresult = this._handleSpeechResult.bind(this);\n  }\n\n  start() {\n    this._speechRecognition.start();\n    this._listening = true;\n  }\n\n  stop() {\n    this._speechRecognition.stop();\n    this._listening = false;\n  }\n\n  _handleSpeechResult(e) {\n    const sentence = e.results[e.results.length - 1][0].transcript.trim();\n    this.emit(sentence);\n  }\n}\n\nexport default SpeechListener;\n\n\n\n// WEBPACK FOOTER //\n// ./src/client/speech_listener.js","import SpeechEmitter from './speech_emitter';\n\n// An instance of the SpeechNode class represents a single node in an entire tree where\n// we can register events to voice commands in sequence.\n//\n// Example:\n//\n//   - \"Show me a list of all my expenses throughout the entire year\"\n//   - \"Please sort the list\"\n//\nclass SpeechNode {\n  constructor(speechEmitter, parentNode) {\n    if (speechEmitter == null) {\n      throw TypeError('speech emitter must be provided');\n    }\n\n    if (!(speechEmitter instanceof SpeechEmitter)) {\n      throw TypeError('first argument must be a speech emitter');\n    }\n\n    if (parentNode && !(parentNode instanceof SpeechNode)) {\n      throw TypeError('second argument must be a speech node');\n    }\n\n    this.speechEmitter = speechEmitter;\n    this.parentNode = parentNode;\n    // We can register multiple tests for a single handler. This array is used to\n    // accumulate tests until their handler is being specified, in which case this array\n    // pipes itself to the global tests array\n    this.testsBatch = [];\n    // A test-handler pairs array which will be used to register itself after the speech\n    // commands map has been zeroed\n    this.tests = [];\n  }\n\n  on(test) {\n    if (test == null) {\n      throw TypeError('test must be provided');\n    }\n\n    if (!(test instanceof RegExp) &&\n        typeof test != 'string' &&\n        typeof test != 'function') {\n      throw TypeError('test must be a regular expression, a string or a function');\n    }\n\n    // Accumulate test for the current session\n    this.testsBatch.push(test);\n\n    return this;\n  }\n\n  invoke(handler) {\n    if (handler == null) {\n      throw TypeError('test handler must be provided');\n    }\n\n    if (typeof handler != 'function') {\n      throw TypeError('test handler must be a function');\n    }\n\n    const wrappedHandler = (...matches) => {\n      // Re-register all tests of the current node and above, discarding all events\n      // of child nodes\n      this.speechEmitter.off();\n\n      this.getTestsRecursively().forEach(([test, handler]) => {\n        this.speechEmitter.on(test, handler);\n      });\n\n      // If the handler returns a function it means that the user would like to keep\n      // building the speech tree\n      const speechNodeRequest = handler(...matches);\n\n      if (typeof speechNodeRequest != 'function') return;\n\n      speechNodeRequest(new SpeechNode(this.speechEmitter, this));\n    };\n\n    this.testsBatch.forEach((test) => {\n      this.speechEmitter.on(test, wrappedHandler);\n    });\n\n    // Compose test-handler pairs\n    const testsBatch = this.testsBatch.map((test) => {\n      return [test, wrappedHandler];\n    });\n\n    // Pipe tests for current session\n    this.tests.push(...testsBatch);\n    this.testsBatch = [];\n\n    return this;\n  }\n\n  // Gets tests of the current node and all its parents\n  getTestsRecursively() {\n    let parentTests;\n\n    if (this.parentNode) {\n      parentTests = this.parentNode.getTestsRecursively();\n    }\n    else {\n      parentTests = [];\n    }\n\n    return this.tests.concat(parentTests);\n  }\n}\n\nexport default SpeechNode;\n\n\n\n// WEBPACK FOOTER //\n// ./src/client/speech_node.js"],"sourceRoot":""}